# frozen_string_literal: true
require 'test_helper'
require 'tempfile'

module CI::Queue
  # This test reproduces the ToggleHelper FLAGS issue with lazy loading
  class ToggleHelperSimulationTest < Minitest::Test
    def setup
      @loader = LazyLoader.new
    end

    def test_reproduce_toggle_helper_pattern_with_require
      # Create a test file that simulates Shopify's ToggleHelper pattern
      test_file = create_toggle_helper_test_file

      begin
        # Simulate what the leader does: require the file
        require(test_file.path)

        # Get the test class and call runnable_methods (like Minitest.loaded_tests does)
        klass = Object.const_get('SimulatedToggleTest')
        methods_from_leader = klass.runnable_methods

        puts "\n=== Leader Process Simulation ==="
        puts "Methods generated by leader: #{methods_from_leader.size}"
        puts "Sample methods: #{methods_from_leader.first(5).join(', ')}"

        # Verify the leader generated methods with FLAGS
        assert methods_from_leader.any? { |m| m.to_s.include?('_FLAGS:') },
               "Leader should generate methods with FLAGS"

        # Find a specific FLAGS method
        flags_method = methods_from_leader.find { |m| m.to_s.include?('_FLAGS:test_flag:ON') }
        assert flags_method, "Leader should generate ON variant"

        puts "Target method for queue: #{flags_method}"

        # Now simulate what a worker does in a SEPARATE process
        # We can't truly fork here, but we can simulate by clearing the processed flag
        klass.remove_instance_variable(:@toggle_helper_processed)

        # Worker calls runnable_methods again
        methods_from_worker = klass.runnable_methods

        puts "\n=== Worker Process Simulation ==="
        puts "Methods generated by worker: #{methods_from_worker.size}"
        puts "Sample methods: #{methods_from_worker.first(5).join(', ')}"

        # Check if the same method exists
        method_found = methods_from_worker.include?(flags_method)

        puts "Worker has the same FLAGS method? #{method_found}"
        puts "\n"

        assert method_found,
               "Worker should generate the same FLAGS methods as leader. " \
               "Leader had: #{flags_method}, worker has: #{methods_from_worker.select { |m| m.to_s.start_with?('test_example') }.join(', ')}"

      ensure
        Object.send(:remove_const, 'SimulatedToggleTest') if defined?(SimulatedToggleTest)
        test_file.unlink
      end
    end

    def test_reproduce_with_lazy_loader
      # Create a test file that simulates ToggleHelper
      test_file = create_toggle_helper_test_file

      begin
        # Simulate leader: load file and get methods
        require(test_file.path)
        leader_klass = Object.const_get('SimulatedToggleTest')
        leader_methods = leader_klass.runnable_methods
        flags_method = leader_methods.find { |m| m.to_s.include?('_FLAGS:test_flag:ON') }

        puts "\n=== LazyLoader Test ==="
        puts "Leader generated: #{flags_method}"

        # Clear the constant to simulate fresh worker process
        Object.send(:remove_const, 'SimulatedToggleTest')

        # Now use LazyLoader like a worker would
        @loader.set_manifest({ 'SimulatedToggleTest' => test_file.path })
        @loader.load_class('SimulatedToggleTest')

        worker_klass = @loader.find_class('SimulatedToggleTest')
        worker_methods = worker_klass.runnable_methods

        puts "Worker generated #{worker_methods.size} methods"
        puts "Looking for: #{flags_method}"

        method_found = worker_methods.include?(flags_method)
        puts "Found in worker? #{method_found}"

        if !method_found
          puts "Worker methods with FLAGS: #{worker_methods.select { |m| m.to_s.include?('_FLAGS:') }.join(', ')}"
        end

        assert method_found,
               "LazyLoader should generate the same methods as direct require"

      ensure
        Object.send(:remove_const, 'SimulatedToggleTest') if defined?(SimulatedToggleTest)
        test_file.unlink
      end
    end

    private

    def create_toggle_helper_test_file
      file = Tempfile.new(['simulated_toggle_test_', '.rb'])
      file.write(<<~RUBY)
        class SimulatedToggleTest < Minitest::Test
          # Simulate ToggleHelper's pattern
          @toggle_helper_processed = false
          @flags_to_test = [{ name: 'test_flag', state: :both }]

          class << self
            attr_accessor :toggle_helper_processed, :flags_to_test

            # Override runnable_methods like ToggleHelper does
            def runnable_methods
              process_flags unless @toggle_helper_processed
              super
            end

            def process_flags
              return if @toggle_helper_processed
              @toggle_helper_processed = true

              # Get base test methods - EXCLUDE already-generated FLAGS methods (idempotent fix)
              base_methods = instance_methods(false).grep(/^test_/).reject { |m| m.to_s.include?('_FLAGS:') }

              # Generate ON and OFF variants like ToggleHelper does
              base_methods.each do |method|
                # Generate ON variant
                define_method("\#{method}_FLAGS:test_flag:ON") do
                  # Set flag to ON, then call base method
                  send(method)
                end

                # Generate OFF variant
                define_method("\#{method}_FLAGS:test_flag:OFF") do
                  # Set flag to OFF, then call base method
                  send(method)
                end
              end
            end
          end

          def test_example
            assert true
          end

          def test_another
            assert true
          end
        end
      RUBY
      file.close
      file
    end
  end
end
